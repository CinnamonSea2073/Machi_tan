<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <title>ç”Ÿå¾’ç”»é¢ - Machi_tan</title>
  <link rel="stylesheet" href="/static/style.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body{margin:0;padding:0;overflow:hidden}
    #map{width:100vw;height:100vh}
    .voice-button{
      position:fixed;left:50%;transform:translateX(-50%);bottom:32px;
      background:#1976d2;color:#fff;padding:18px 28px;border-radius:50px;
      border:none;font-size:16px;font-weight:600;box-shadow:0 4px 12px rgba(25,118,210,0.4);
      cursor:pointer;user-select:none;touch-action:none;z-index:1000;
      transition:all 0.2s
    }
    .voice-button:active{background:#1565c0;transform:translateX(-50%) scale(0.95)}
    .recording{background:#d32f2f !important;animation:pulse 1s infinite}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:0.7}}
    /* Next destination marker (prominent dot) */
    .next-dest-marker{
      width:26px;height:26px;border-radius:26px;background:#ffb300;border:3px solid #fff;box-shadow:0 0 12px rgba(255,179,0,0.6)
    }
    /* Debug marker style */
    .debug-marker{
      width:22px;height:22px;border-radius:22px;background:#e91e63;border:2px solid #fff;box-shadow:0 0 10px rgba(233,30,99,0.6)
    }
    /* Tutorial bubble: use SVG background, thin border (2px), no shadows, and entrance scale animation */
    .tutorial-bubble{
      background:transparent;color:#111;border-radius:14px;padding:0;max-width:94vw;position:relative;box-sizing:border-box;display:inline-block;transform:translateY(-12px);
      width:315px;max-width:94vw;
      filter: drop-shadow(0 4px 0 #929292);
    }
    .tutorial-bubble .bubble-svg svg{width:100%;height:auto;display:block}
    /* overlay content (text/form) centered over SVG, accounting for pointer triangle at bottom */
    .tutorial-bubble .bubble-content{position:absolute;left:0;right:0;top:0;bottom:40px;display:flex;align-items:center;justify-content:center;padding:18px 20px;box-sizing:border-box}
    .tutorial-bubble .bubble-text{font-size:16px;line-height:1.5;color:#111;text-align:center}

    /* entrance animation: scale-only (no drop-shadow) */
    @keyframes bubblePop {
      0% { transform: translateY(6px) scale(0.98); opacity:0 }
      60% { transform: translateY(-6px) scale(1.04); opacity:1 }
      100% { transform: translateY(0) scale(1); opacity:1 }
    }
    .bubble-animate{ animation: bubblePop 420ms cubic-bezier(.22,.9,.5,1) both; transform-origin: center top }
  </style>
</head>
<body>
  <!-- Tutorial screen (fullscreen, shown first) - redesigned: character + speech bubble -->
  <div id="tutorialScreen" style="position:fixed;top:0;left:0;width:100vw;height:100vh;background:#ffffff;z-index:9999;display:flex;align-items:center;justify-content:center;color:#111;font-family:sans-serif;padding:24px;box-sizing:border-box">
    <div id="tutorialBox" style="width:360px;max-width:94vw;position:relative;display:flex;flex-direction:column;align-items:center;gap:20px">
      <!-- speech bubble (moved above character) -->
      <div id="tutorialBubble" class="tutorial-bubble">
        <div class="bubble-svg">
          <svg width="315" height="121" viewBox="0 0 315 121" fill="none" xmlns="http://www.w3.org/2000/svg">
            <g>
              <path d="M304.075 0H10.9249C4.89123 0 4.34115e-06 4.87327 4.34115e-06 10.8848L0 78.461C0 84.4724 4.89123 89.3457 10.9249 89.3457H119.945C123.132 89.3457 126.189 90.6139 128.44 92.8706L148.72 113.199C153.518 118.009 161.348 117.88 165.985 112.915L184.441 93.1548C186.71 90.7251 189.886 89.3457 193.211 89.3457H304.075C310.109 89.3457 315 84.4724 315 78.461V10.8848C315 4.87327 310.109 0 304.075 0Z" fill="white"/>
              <path d="M10.9248 1H304.075C309.56 1.00003 314 5.42905 314 10.8848V78.4609C314 83.9167 309.56 88.3457 304.075 88.3457H193.211C189.609 88.3457 186.168 89.8404 183.71 92.4727L165.255 112.232C161.004 116.784 153.826 116.902 149.428 112.493L129.148 92.1641C126.71 89.7195 123.398 88.3458 119.945 88.3457H10.9248C5.44001 88.3457 1 83.9167 1 78.4609V10.8848C1 5.59944 5.167 1.27752 10.4141 1.0127L10.9248 1Z" stroke="#929292" stroke-width="2"/>
            </g>
          </svg>
        </div>
        <div class="bubble-content">
          <div id="tutorialBubbleText" class="bubble-text">ç”»é¢ã‚’ã‚¿ãƒƒãƒ—ã—ã¦é€²ã‚ã¦ãã ã•ã„ã€‚</div>
        </div>
      </div>

      <!-- character placeholder (moved below bubble) -->
      <div id="tutorialCharacter" style="width:210px;height:210px;border-radius:16px;background:#d9d9d9;display:flex;align-items:center;justify-content:center;"></div>      <div id="tutorialHint" style="font-size:13px;opacity:0.9;text-align:center;color:rgba(0,0,0,0.7)">ã©ã“ã§ã‚‚ã‚¿ãƒƒãƒ—ã§æ¬¡ã¸</div>
    </div>
  </div>

  <!-- Debug panel (shown only when status is ãƒ‡ãƒãƒƒã‚°) -->
  <div id="debugPanel" style="position:fixed;left:12px;top:12px;z-index:10000;background:rgba(0,0,0,0.85);color:#fff;padding:16px;border-radius:12px;box-shadow:0 4px 12px rgba(0,0,0,0.3);font-size:14px;display:none">
    <h3 style="margin:0 0 12px 0;font-size:16px;font-weight:600">ğŸ”§ ãƒ‡ãƒãƒƒã‚°ãƒ‘ãƒãƒ«</h3>
    <button id="debugShowTutorial" style="display:block;width:100%;margin-bottom:8px;padding:8px 12px;background:#4caf50;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px">ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚’å†è¡¨ç¤º</button>
    <button id="debugShowMap" style="display:block;width:100%;padding:8px 12px;background:#2196f3;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px">åœ°å›³ãƒšãƒ¼ã‚¸ã¸ç§»å‹•</button>
  </div>

  <div id="map" style="display:none"></div>
  <button id="voiceBtn" class="voice-button" style="display:none">ğŸ¤ é•·æŠ¼ã—ã§å ±å‘Š</button>
  <!-- Level meter for debugging -->
  <div id="levelMeterRoot" style="position:fixed;right:18px;top:18px;z-index:1200;display:none">
    <div id="levelMeter" style="width:160px;height:12px;background:#eee;border-radius:8px;overflow:hidden;box-shadow:0 2px 6px rgba(0,0,0,0.08)"></div>
    <div id="levelDebug" style="margin-top:6px;text-align:right;font-size:12px;color:#333;min-width:160px">--</div>
  </div>

  <div id="modalRoot"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="/static/common.js"></script>
  <!-- lottie-web for character animation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.9.6/lottie.min.js"></script>
  <script>
    // Tutorial story messages with character animations
    const tutorialStory = [
      { 
        title: 'ãŸã¬ã‘ã‚“', 
        message: 'ãã‚‡ã†ã¯ã€ãŸã‚“ã‘ã‚“ã‚’ã¦ã¤ã ã„ã«\næ¥ã¦ãã‚Œã¦ã€ã‚ã‚ŠãŒã¨ã†ï¼', 
        character: 'https://lottie.host/f388a0b2-cce4-4681-a943-d8fb67a984d7/XfkX4AvJZo.json'
      },
      { 
        title: 'ãŸã¬ã‘ã‚“', 
        message: 'ã¼ãã¯ã€ãŸã¬ã‘ã‚“ã€ï¼ã‚ˆã‚ã—ãã­ï¼ï¼', 
        character: 'https://lottie.host/f388a0b2-cce4-4681-a943-d8fb67a984d7/XfkX4AvJZo.json'
      },
      { 
        title: 'ãŸã¬ã‘ã‚“', 
        message: 'ãã‚‡ã†ã®ãŸã‚“ã‘ã‚“ãƒ«ãƒ¼ãƒˆã¯\næ°´ã«ã‹ã‚“ã‘ã„ã™ã‚‹ã„ãã‚‚ã®ã€‚', 
        character: 'https://lottie.host/98be370f-0447-4347-b2c1-8256fc4c440d/HdoBME0ofD.json'
      },
      { 
        title: 'ãŸã¬ã‘ã‚“', 
        message: 'ã‘ã‚Œã©ã€ãã®ã„ãã‚‚ã®ãŒã ã‚Œã‹\nã¼ãã«ã‚‚ã‚ã‹ã‚‰ãªã„ã‚“ã ...', 
        character: 'https://lottie.host/f26cbe82-399e-4375-aa69-d2f5ac331887/0wfU1QJrz7.json'
      },
      { 
        title: 'ãŸã¬ã‘ã‚“', 
        message: 'ã€æ°—ã¥ãã€ã‚’ã‚ã¤ã‚ã¦ã„ã‘ã°ã€\nã ã‚Œã‹ã‚ã‹ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã‚ˆï¼', 
        character: 'https://lottie.host/98be370f-0447-4347-b2c1-8256fc4c440d/HdoBME0ofD.json'
      },
      { 
        title: 'ãŸã¬ã‘ã‚“', 
        message: 'ã€æ°—ã¥ãã€ã¯ã€ãƒˆãƒ©ãƒ³ã‚·ãƒ¼ãƒãƒ¼ã§\nã¼ãã«å ±å‘Šã—ã¦ã­ï¼', 
        character: 'https://lottie.host/f388a0b2-cce4-4681-a943-d8fb67a984d7/XfkX4AvJZo.json'
      },
      { 
        title: 'ãŸã¬ã‘ã‚“', 
        message: 'ãƒˆãƒ©ãƒ³ã‚·ãƒ¼ãƒãƒ¼ã‚’ç”¨æ„ã—ã¦ï¼', 
        character: 'https://lottie.host/98be370f-0447-4347-b2c1-8256fc4c440d/HdoBME0ofD.json'
      },
      { 
        title: 'ãŸã¬ã‘ã‚“', 
        message: 'ãƒœã‚¿ãƒ³ã‚’ãŠã—ãªãŒã‚‰\nã€Œã˜ã‚…ã‚“ã³OKï¼ã€ã¨ã„ã£ã¦ã¿ã‚ˆã†', 
        character: 'https://lottie.host/98be370f-0447-4347-b2c1-8256fc4c440d/HdoBME0ofD.json'
      },
      { 
        title: 'ãŸã¬ã‘ã‚“', 
        message: 'ã•ã„ã”ã«ã€ãã¿ã®ãªã¾ãˆã¯ï¼Ÿ', 
        character: 'https://lottie.host/f388a0b2-cce4-4681-a943-d8fb67a984d7/XfkX4AvJZo.json',
        isNameInput: true
      },
      { 
        title: 'ãŸã¬ã‘ã‚“', 
        message: 'ãã‚Œã˜ã‚ƒã‚ã€{name}\nãã‚‡ã†ã¯ã‚ˆã‚ã—ãã­ï¼', 
        character: 'https://lottie.host/f388a0b2-cce4-4681-a943-d8fb67a984d7/XfkX4AvJZo.json',
        isNameDisplay: true
      }
    ]
    let tutorialStep = 0
    // Lottie animation instances (preloaded)
    let lottieAnim = null
    let preloadedAnimations = {}
    let currentAnimationUrl = null

    // preload all character animations to avoid loading delays
    function preloadAllAnimations() {
      if(typeof lottie === 'undefined' || !lottie) {
        setTimeout(preloadAllAnimations, 100)
        return
      }
      
      // collect unique animation URLs
      const animationUrls = [...new Set(tutorialStory.map(s => s.character).filter(Boolean))]
      console.log('Preloading animations:', animationUrls)
      
      let loadedCount = 0
      animationUrls.forEach(url => {
        fetch(url).then(r => r.json()).then(data => {
          preloadedAnimations[url] = data
          loadedCount++
          console.log(`Preloaded animation ${loadedCount}/${animationUrls.length}: ${url}`)
          
          // when all loaded, start with first animation
          if(loadedCount === animationUrls.length) {
            console.log('All animations preloaded, initializing first character')
            initializeFirstCharacter()
          }
        }).catch(e => {
          console.warn('Failed to preload animation:', url, e)
          loadedCount++
          if(loadedCount === animationUrls.length) {
            initializeFirstCharacter()
          }
        })
      })
    }
    
    function initializeFirstCharacter() {
      const lottieContainer = document.createElement('div')
      lottieContainer.id = 'lottieCharacter'
      lottieContainer.style.width = '210px'
      lottieContainer.style.height = '210px'
      lottieContainer.style.display = 'flex'
      lottieContainer.style.alignItems = 'center'
      lottieContainer.style.justifyContent = 'center'
      lottieContainer.style.pointerEvents = 'none'
      
      const char = document.getElementById('tutorialCharacter')
      if(char){ char.innerHTML = ''; char.appendChild(lottieContainer) }
      
      // load first character animation
      if(tutorialStory[0] && tutorialStory[0].character) {
        switchToCharacter(tutorialStory[0].character)
      }
    }
    
    // call preload after a short delay to ensure DOM and lottie lib are ready
    setTimeout(preloadAllAnimations, 50)
    
    // function to instantly switch to preloaded character animation
    function switchToCharacter(url) {
      if(!url || url === currentAnimationUrl) return
      
      const lottieContainer = document.getElementById('lottieCharacter')
      if(!lottieContainer) return
      
      try {
        // destroy existing animation
        if(lottieAnim) {
          try { lottieAnim.destroy() } catch(e) {}
        }
        
        // clear container
        lottieContainer.innerHTML = ''
        
        // use preloaded data if available
        if(preloadedAnimations[url]) {
          lottieAnim = lottie.loadAnimation({
            container: lottieContainer,
            renderer: 'svg',
            loop: false,
            autoplay: false,
            animationData: preloadedAnimations[url]
          })
          window.lottieAnim = lottieAnim
          currentAnimationUrl = url
          console.log('Switched to preloaded character:', url)
          
          // play animation
          setTimeout(()=>{
            if(lottieAnim) {
              try { lottieAnim.goToAndPlay(0, true) } catch(e) {}
            }
          }, 50)
        } else {
          // fallback: show placeholder if not preloaded
          console.warn('Animation not preloaded:', url)
          lottieContainer.innerHTML = '<div style="font-size:24px;color:#666;display:flex;align-items:center;justify-content:center;width:100%;height:100%;">ãŸ</div>'
        }
      } catch(e) {
        console.warn('switchToCharacter error:', e)
      }
    }
    
    // function to complete tutorial and show map
    async function completeNameRegistration() {
      // Register with API
      await registerStudentWithAPI()
      // Show map
      document.getElementById('tutorialScreen').style.display = 'none'
      document.getElementById('map').style.display = 'block'
      document.getElementById('voiceBtn').style.display = 'block'
      document.getElementById('levelMeterRoot').style.display = 'block'
      if (!mapInitialized) initMap()
      loadTodayCourse()
    }

    function showTutorialStep(step) {
      const box = document.getElementById('tutorialBox')
      const char = document.getElementById('tutorialCharacter')
      const bubbleText = document.getElementById('tutorialBubbleText')
      const bubble = document.getElementById('tutorialBubble')
      
      console.log('showTutorialStep called with step:', step, 'total steps:', tutorialStory.length)
      
      if (step >= tutorialStory.length) {
        // end of tutorial, proceed to map
        console.log('Tutorial completed, proceeding to map')
        completeNameRegistration()
        return
      }
      const s = tutorialStory[step]
      
      // handle special steps
      if(s.isNameInput) {
        // show message in bubble first
        if(bubbleText) bubbleText.innerHTML = s.message.replace(/\n/g, '<br>')
        showNameInputForm()
        return
      }
      
      if(s.isNameDisplay) {
        console.log('Processing isNameDisplay step')
        const playerName = localStorage.getItem('studentName') || 'ãŸã‚“ã‘ã‚“ãŸã„'
        console.log('Player name from localStorage:', playerName)
        const displayMessage = s.message.replace('{name}', playerName)
        console.log('Display message:', displayMessage)
        if(bubbleText) bubbleText.innerHTML = displayMessage.replace(/\n/g, '<br>')
        // Update hint to indicate this is the final step
        const hint = document.getElementById('tutorialHint')
        if(hint) {
          hint.textContent = 'ã‚¿ãƒƒãƒ—ã—ã¦ãŸã‚“ã‘ã‚“ã‚’é–‹å§‹ï¼'
          console.log('Updated hint text')
        }
      } else {
        if(bubbleText) bubbleText.innerHTML = s.message.replace(/\n/g, '<br>')
      }
      
      // switch character animation if different from current
      if(s.character) {
        switchToCharacter(s.character)
      }
      // trigger entrance animation on the bubble
      try{
        if(bubble){ bubble.classList.remove('bubble-animate'); void bubble.offsetWidth; bubble.classList.add('bubble-animate') }
        // remove animation class after it finishes so it can replay next step
        setTimeout(()=>{ try{ if(bubble) bubble.classList.remove('bubble-animate') }catch(_){} }, 600)
      }catch(e){/* ignore */}
      // play lottie animation (if available) when step advances
      try{
        const anim = window.lottieAnim || lottieAnim
        console.log('Trying to play Lottie animation, anim=', anim)
        if(anim && typeof anim.goToAndPlay === 'function'){
          anim.goToAndPlay(0, true)
          console.log('Lottie animation started from frame 0')
        } else if(anim && typeof anim.play === 'function'){
          anim.goToAndStop(0, true)
          anim.play()
          console.log('Lottie animation played with fallback method')
        } else {
          console.warn('No valid Lottie animation instance found')
        }
      }catch(e){console.warn('Lottie play error:', e)}
    }

    function showNameInputForm() {
      // Create name input form in fixed position to avoid layout changes
      const tutorialScreen = document.getElementById('tutorialScreen')
      if(!tutorialScreen) return
      
      // Remove existing name form if present
      const existingForm = document.getElementById('nameInputForm')
      if(existingForm) existingForm.remove()
      
      // Create form element with fixed positioning
      const nameForm = document.createElement('div')
      nameForm.id = 'nameInputForm'
      nameForm.style.cssText = `
        position: fixed;
        bottom: 120px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        text-align:center;
        padding:20px;
        background:rgba(255,255,255,0.95);
        border-radius:12px;
        box-shadow:0 4px 12px rgba(0,0,0,0.15);
        max-width: 300px;
        width: 90%;
      `
      nameForm.innerHTML = `
        <div style="margin-bottom:12px;font-size:16px;color:#333">ã‚ãªãŸã®åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</div>
        <input type="text" id="studentNameInput" placeholder="ä¾‹: å±±ç”°å¤ªéƒ" style="width:100%;max-width:260px;padding:12px 16px;border:2px solid #e5e5e5;border-radius:8px;font-size:16px;margin-bottom:16px;box-sizing:border-box;text-align:center" />
        <div>
          <button id="registerNameBtn" style="background:#667eea;color:#fff;padding:12px 24px;border:none;border-radius:8px;font-size:16px;cursor:pointer;font-weight:600">ç™»éŒ²ã—ã¦æ¬¡ã¸</button>
        </div>
      `
      
      // Insert form in tutorial screen without affecting layout
      tutorialScreen.appendChild(nameForm)
      
      // Attach event listener
      const btn = document.getElementById('registerNameBtn')
      if(btn) {
        btn.addEventListener('click', (event)=>{
          // Prevent event bubbling to tutorial tap handler
          event.stopPropagation()
          
          const name = document.getElementById('studentNameInput').value.trim()
          if (!name) {
            alert('åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„')
            return
          }
          // Store name and remove form
          localStorage.setItem('studentName', name)
          console.log('Name registered:', name)
          nameForm.remove()
          // Move to final greeting step (Step 10 = index 9)
          tutorialStep = 9
          console.log('Moving to step 9 (Step 10), tutorialStep is now:', tutorialStep)
          showTutorialStep(tutorialStep)
        })
      }
      
      // Focus input
      setTimeout(()=>{
        const input = document.getElementById('studentNameInput')
        if(input) input.focus()
      }, 100)
    }

    async function registerStudentWithAPI() {
      const name = localStorage.getItem('studentName')
      if (!name) return
      try {
        // Call API to register student and get UUID
        const res = await fetch('/api/students', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name })
        })
        if (!res.ok) throw new Error('ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ')
        const data = await res.json()
        const studentUuid = data.student_id
        // Store UUID in localStorage
        localStorage.setItem('studentUuid', studentUuid)
      } catch (err) {
        console.error('Student registration error:', err)
        // Continue even if API fails - use local name
      }
    }

    const tutorialNextBtn = document.getElementById('tutorialNextBtn')
    if(tutorialNextBtn){
      tutorialNextBtn.addEventListener('click', () => {
        tutorialStep++
        showTutorialStep(tutorialStep)
      })
    }

    // New: advance tutorial on tap anywhere on the tutorial screen
    function attachTutorialTap(){
      const ts = document.getElementById('tutorialScreen')
      if(!ts) return
      // remove existing to avoid double-binding
      try{ ts.removeEventListener('click', window.__tutorialTapHandler) }catch(e){}
      window.__tutorialTapHandler = function(ev){ 
        // Don't advance if name input form is visible
        if(document.getElementById('nameInputForm')) return;
        // Don't advance if name input is visible (fallback check)
        if(document.getElementById('studentNameInput')) return; 
        tutorialStep++; 
        showTutorialStep(tutorialStep) 
      }
      ts.addEventListener('click', window.__tutorialTapHandler)
    }
    attachTutorialTap()
    // fallback: ensure attachment after DOM ready
    document.addEventListener('DOMContentLoaded', ()=>{ setTimeout(attachTutorialTap, 50) })

    async function saveComment(text){
      const studentUuid = localStorage.getItem('studentUuid') || null
      // capture current location if available
      let lat = null, lon = null
      try{
        if(posCircle){ const c = posCircle.getLatLng(); lat = c.lat; lon = c.lng }
        else if(map && map.getCenter){ const c = map.getCenter(); lat = c.lat; lon = c.lng }
      }catch(e){ /* ignore */ }
      const payload = { user_id: studentUuid ? studentUuid : 'anonymous', text: text, student_id: studentUuid, lat: lat, lon: lon }
      console.log('[saveComment] payload=', payload)
      const res = await fetch('/api/comments', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload)})
      if(!res.ok) throw new Error('ã‚³ãƒ¡ãƒ³ãƒˆä¿å­˜å¤±æ•—')
      const j = await res.json()
      console.log('[saveComment] saved', j)
      // add marker immediately
      try{ if(j && j.comment_id){ addCommentMarker(j) } }catch(e){console.warn('addCommentMarker failed', e)}
      return j
    }


    // comment markers
    let commentMarkers = {}

    function addCommentMarker(comment){
      try{
        // accept 0 coordinates; check for null/undefined explicitly
        const lat = (comment.lat !== undefined && comment.lat !== null) ? Number(comment.lat) : null
        const lon = (comment.lon !== undefined && comment.lon !== null) ? Number(comment.lon) : null
        if(lat === null || lon === null) return
        if(Number.isNaN(lat) || Number.isNaN(lon)) return
        // avoid duplicate
        if(commentMarkers[comment.comment_id]) return
  const starHtml = `
    <div style="position:relative;width:40px;height:40px;display:flex;align-items:center;justify-content:center;">
      <div style="position:absolute;width:40px;height:40px;border-radius:50%;background:rgba(255,215,0,0.18);box-shadow:0 2px 8px rgba(0,0,0,0.15);"></div>
      <div style="color:#FFD700;font-size:22px;z-index:2;text-shadow:0 2px 6px rgba(0,0,0,0.35);">â˜…</div>
    </div>`
  const starIcon = L.divIcon({className:'', html:starHtml, iconSize:[40,40], iconAnchor:[20,20]})
  const m = L.marker([lat, lon], { icon: starIcon, zIndexOffset: 1000 }).addTo(map)
        // format popup with student name and timestamp
        let timeStr = ''
        try{ timeStr = comment.created_at ? new Date(comment.created_at).toLocaleString('ja-JP') : '' }catch(e){}
        const popupHtml = `<div style="min-width:160px"><strong>${comment.student_name || comment.user_id}</strong>${timeStr?`<div style=\"font-size:12px;color:#666\">${timeStr}</div>`:''}<div style=\"margin-top:6px\">${comment.text}</div></div>`
        m.bindPopup(popupHtml)
        commentMarkers[comment.comment_id] = m
      }catch(e){console.warn('addCommentMarker error', e)}
    }

    async function loadExistingComments(){
      try{
        const res = await fetch('/api/comments/with_students')
        if(!res.ok) return
        const arr = await res.json()
        arr.forEach(c => addCommentMarker(c))
      }catch(e){console.warn('loadExistingComments failed', e)}
    }

    // poll for new comments every N seconds and add markers for unseen ones
    let lastCommentPoll = null
    async function pollNewComments(){
      try{
        const res = await fetch('/api/comments')
        if(!res.ok) return
        const arr = await res.json()
        for(const c of arr){
          if(!commentMarkers[c.comment_id]) addCommentMarker(c)
        }
      }catch(e){console.warn('pollNewComments failed', e)}
    }

    // start polling when map is initialized
    setInterval(()=>{ if(mapInitialized) pollNewComments() }, 5000)

    // Check if student already registered
    if (localStorage.getItem('studentUuid')) {
      // skip tutorial
      document.getElementById('tutorialScreen').style.display = 'none'
      document.getElementById('map').style.display = 'block'
      document.getElementById('voiceBtn').style.display = 'block'
      document.getElementById('levelMeterRoot').style.display = 'block'
    } else {
      // show tutorial
      showTutorialStep(tutorialStep)
    }

    // map setup - centered on Tokyo, will update with real location
    let mapInitialized = false
    let map = null
    let posCircle = null
  let todayRouteLayer = null
    // current position marker update function (moved to top-level so debug can call it)
    function updatePos(lat,lon){
      try{
        if(!map) return
        if(posCircle) {try{map.removeLayer(posCircle)}catch(e){}
        }
        posCircle = L.circle([lat,lon], {radius:12, color:'#00b0ff', fillColor:'#aee6ff', fillOpacity:0.6}).addTo(map)
        try{ map.panTo([lat,lon]) }catch(e){}
        // when we have route coords, evaluate proximity to next dest
        evaluateProximity(lat, lon)
      }catch(e){console.warn('updatePos error', e)}
    }
    // staged reveal state
    let routeCoords = []
    let revealedIndex = -1 // index of last revealed point
    let visitedLine = null
    let nextDestMarker = null
    // debug marker (only when status == ãƒ‡ãƒãƒƒã‚°)
    let debugMarker = null
    let debugMode = false

    function initMap() {
      if (mapInitialized) return
      mapInitialized = true
      map = L.map('map', {
        zoomControl: true,
        attributionControl: true
      }).setView([35.6812, 139.7671], 15);
      
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: 'Â© OpenStreetMap'
      }).addTo(map);

      // current position marker (blue circle) is handled by top-level updatePos()

      if(navigator.geolocation){
        const geoOptions = { enableHighAccuracy: true, maximumAge: 1000, timeout: 10000 };
        navigator.geolocation.getCurrentPosition(
          p => updatePos(p.coords.latitude, p.coords.longitude),
          e => console.warn('geolocation.getCurrentPosition error', e),
          geoOptions
        );
        navigator.geolocation.watchPosition(
          p => updatePos(p.coords.latitude, p.coords.longitude),
          e => console.warn('geolocation.watchPosition error', e),
          geoOptions
        );
      }
      // load existing comment markers
      setTimeout(()=>{ try{ loadExistingComments() }catch(e){} }, 500)
      // also enable debug marker placement when in debug mode
      map.on('click', e => {
        if(!debugMode) return
        placeDebugMarker(e.latlng.lat, e.latlng.lng)
      })
    }

    function setCurrentPositionForDebug(lat, lon){
      // emulate current position using debug marker
      updatePos(lat, lon)
    }


    // Load today's course (if set) and draw on the student map
    async function loadTodayCourse(){
      try{
        const res = await fetch('/api/class_course')
        if(!res.ok) return
        const t = await res.json()
        const courseId = t.course_id || t.course_of_day || null
        if(!courseId) return
        // fetch course GPX
        const r = await fetch(`/api/courses/${courseId}`)
        if(!r.ok) return
        const courseData = await r.json()
        const gpxContent = courseData.gpx || courseData.content || courseData.gpx_content
        if(!gpxContent) return
        // parse GPX and extract track points
        const parser = new DOMParser()
        const gpxDoc = parser.parseFromString(gpxContent, 'text/xml')
        const trackPoints = gpxDoc.querySelectorAll('trkpt')
        if(!trackPoints || trackPoints.length === 0) return
        const coords = []
        trackPoints.forEach(pt=>{
          const lat = parseFloat(pt.getAttribute('lat'))
          const lon = parseFloat(pt.getAttribute('lon'))
          if(!isNaN(lat) && !isNaN(lon)) coords.push([lat, lon])
        })
        if(coords.length === 0) return
        // store coords for staged reveal
        routeCoords = coords
        revealedIndex = -1
        // remove any full-route layer if exists
        if(todayRouteLayer){ try{ map.removeLayer(todayRouteLayer) }catch(e){} todayRouteLayer = null }
        // remove visited line and markers
        if(visitedLine){ try{ map.removeLayer(visitedLine) }catch(e){} visitedLine = null }
        if(nextDestMarker){ try{ map.removeLayer(nextDestMarker) }catch(e){} nextDestMarker = null }
        // show only the next destination (first point)
        showNextDestination()
      }catch(err){
        console.warn('loadTodayCourse failed', err)
      }
    }

    // If already registered, init map immediately
    if (localStorage.getItem('studentUuid')) {
      initMap()
      loadTodayCourse()
    }

    // compute distance in meters between two lat/lon
    function haversineDistance(lat1, lon1, lat2, lon2){
      const R = 6371000 // meters
      const toRad = v => v * Math.PI / 180
      const dLat = toRad(lat2 - lat1)
      const dLon = toRad(lon2 - lon1)
      const a = Math.sin(dLat/2)*Math.sin(dLat/2) + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)*Math.sin(dLon/2)
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))
      return R * c
    }

    // show the next unrevealed destination as a prominent marker
    function showNextDestination(){
      if(!routeCoords || routeCoords.length === 0) return
      const nextIndex = revealedIndex + 1
      if(nextIndex >= routeCoords.length){
        // all revealed â€” show full route
        revealFullRoute()
        return
      }
      const [lat, lon] = routeCoords[nextIndex]
      // remove existing next marker
      if(nextDestMarker){ try{ map.removeLayer(nextDestMarker) }catch(e){} nextDestMarker = null }
      // use a divIcon for prominent styling
      const icon = L.divIcon({className: '', html: '<div class="next-dest-marker"></div>', iconSize: [26,26]})
      nextDestMarker = L.marker([lat, lon], { icon }).addTo(map)
      // ensure it's visible
      try{ map.panTo([lat, lon]) }catch(e){}
    }

    // reveal the path up to given index (inclusive) as visitedLine
    function revealUpToIndex(idx){
      if(idx < 0) return
      const pts = routeCoords.slice(0, idx+1)
      if(visitedLine){ try{ map.removeLayer(visitedLine) }catch(e){} visitedLine = null }
      visitedLine = L.polyline(pts, { color: '#00b0ff', weight: 4, opacity: 0.9 }).addTo(map)
    }

    // when reaching final reveal, show full route
    function revealFullRoute(){
      if(todayRouteLayer) return
      if(routeCoords.length === 0) return
      todayRouteLayer = L.polyline(routeCoords, { color: '#1976d2', weight: 4, opacity: 0.9 }).addTo(map)
      // remove nextDestMarker and leave visitedLine as-is
      if(nextDestMarker){ try{ map.removeLayer(nextDestMarker) }catch(e){} nextDestMarker = null }
      try{ map.fitBounds(todayRouteLayer.getBounds(), { padding: [20,20] }) }catch(e){}
    }

    // evaluate proximity from current position to next destination
    function evaluateProximity(lat, lon){
      if(!routeCoords || routeCoords.length === 0) return
      const nextIndex = revealedIndex + 1
      if(nextIndex >= routeCoords.length) return
      const [dlat, dlon] = routeCoords[nextIndex]
      const dist = haversineDistance(lat, lon, dlat, dlon)
      // threshold for considering 'arrived' (meters) â€” generous radius
      const ARRIVE_THRESHOLD = 20
      // reveal visited line from start up to current revealedIndex if any
      if(dist <= ARRIVE_THRESHOLD){
        // mark this node as revealed
        revealedIndex = nextIndex
        // draw visited line up to revealedIndex
        revealUpToIndex(revealedIndex)
        // show next destination
        showNextDestination()
        // if we've revealed the last point, show full route
        if(revealedIndex >= routeCoords.length - 1){
          revealFullRoute()
        }
      }
    }

    // debug marker placement (single marker only)
    function placeDebugMarker(lat, lon){
      // only allowed in debug mode
      if(!debugMode) return
      // remove previous debug marker
      if(debugMarker){ try{ map.removeLayer(debugMarker) }catch(e){} debugMarker = null }
      const icon = L.divIcon({className:'', html: '<div class="debug-marker"></div>', iconSize:[22,22]})
      debugMarker = L.marker([lat, lon], { icon }).addTo(map)
      // treat debug marker as current position
      setCurrentPositionForDebug(lat, lon)
    }

    // Debug panel logic: show only if status is ãƒ‡ãƒãƒƒã‚°
    async function checkDebugMode() {
      try {
        const res = await fetch('/api/status')
        if (!res.ok) return
        const data = await res.json()
        const currentStatus = data.status || ''
        if (currentStatus === 'ãƒ‡ãƒãƒƒã‚°') {
          document.getElementById('debugPanel').style.display = 'block'
          debugMode = true
          ensureDebugControls()
        } else {
          document.getElementById('debugPanel').style.display = 'none'
          debugMode = false
        }
      } catch (err) {
        console.warn('Failed to fetch status for debug panel', err)
      }
    }
    checkDebugMode()
    // Re-check every 10 seconds
    setInterval(checkDebugMode, 10000)

    document.getElementById('debugShowTutorial').addEventListener('click', () => {
      // Clear localStorage and reload to show tutorial
      localStorage.removeItem('studentUuid')
      localStorage.removeItem('studentName')
      location.reload()
    })

    document.getElementById('debugShowMap').addEventListener('click', () => {
      // Hide tutorial and show map
      document.getElementById('tutorialScreen').style.display = 'none'
      document.getElementById('map').style.display = 'block'
      document.getElementById('voiceBtn').style.display = 'block'
      document.getElementById('levelMeterRoot').style.display = 'block'
      if (!mapInitialized) initMap()
      // ensure today's course is visible in debug map
      loadTodayCourse()
    })

    function ensureDebugControls(){
      // add a button to place a debug marker if not already present
      if(document.getElementById('placeDebugMarkerBtn')) return
      const btn = document.createElement('button')
      btn.id = 'placeDebugMarkerBtn'
      btn.textContent = 'ãƒ‡ãƒãƒƒã‚°: ç¾åœ¨ä½ç½®ã‚’ã‚»ãƒƒãƒˆ'
      btn.style.display = 'block'
      btn.style.marginTop = '8px'
      btn.style.padding = '8px 12px'
      btn.style.background = '#e91e63'
      btn.style.color = '#fff'
      btn.style.border = 'none'
      btn.style.borderRadius = '6px'
      btn.style.cursor = 'pointer'
      document.getElementById('debugPanel').appendChild(btn)
      btn.addEventListener('click', ()=>{
        if(!mapInitialized) initMap()
        // place marker at map center
        const center = map.getCenter()
        placeDebugMarker(center.lat, center.lng)
      })
    }

  // voice recording: MediaRecorder + analyser for silence detection
  let mediaStream=null, recorder=null, chunks=[], analyser=null, audioCtx=null, sourceNode=null
    const btn=document.getElementById('voiceBtn')
    btn.addEventListener('mousedown', startRecording)
    btn.addEventListener('mouseup', stopRecording)
    btn.addEventListener('touchstart', startRecording)
    btn.addEventListener('touchend', stopRecording)

    async function startRecording(e){
      e.preventDefault()
      try{
        btn.textContent = 'ğŸ”´ éŒ²éŸ³ä¸­...é›¢ã™ã¨é€ä¿¡'
        btn.classList.add('recording')
        if(!mediaStream){
          mediaStream = await navigator.mediaDevices.getUserMedia({audio:true})
        }
        // ensure audio context and analyser exist (recreate if closed earlier)
        // Always (re)create the audio context, source and analyser so
        // they are fresh for every recording. Previously we only created
        // an analyser once and closed the AudioContext on stop which left
        // the analyser bound to a closed context and caused the meter to
        // stop updating on subsequent recordings.
        try{
          if(audioCtx){ try{ audioCtx.close() }catch(_){} }
        }catch(e){}
        audioCtx = new (window.AudioContext || window.webkitAudioContext)()
        try{
          sourceNode = audioCtx.createMediaStreamSource(mediaStream)
        }catch(e){ console.warn('createMediaStreamSource failed', e); sourceNode = null }
        analyser = audioCtx.createAnalyser()
        analyser.fftSize = 2048
        try{
          if(sourceNode && analyser) sourceNode.connect(analyser)
        }catch(e){/* ignore */}
        // perform a short ambient calibration to set dynamic threshold
        await calibrateAmbient(300)
        // reset peak tracker for this recording session
        maxRms = 0
        recorder = new MediaRecorder(mediaStream)
        chunks=[]
        recorder.ondataavailable = ev=>chunks.push(ev.data)
        recorder.start()
        // start measuring volume periodically
        measureSilence()
      }catch(err){
        console.error(err)
        alert('ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒè¨±å¯ã•ã‚Œã¦ã„ã¾ã›ã‚“')
        btn.textContent = 'ğŸ¤ é•·æŠ¼ã—ã§å ±å‘Š'
        btn.classList.remove('recording')
      }
    }

    // simple RMS-based silence measurement
    let _measuring = false
    let lastRms = 0
    let maxRms = 0
    let ambientRms = 0
    let dynamicThreshold = 0.005
    // keep rolling previous values to avoid wild threshold jumps between
    // successive calibrations in the same session
    window._prevAmbientRms = window._prevAmbientRms || null
    window._prevDynamicThreshold = window._prevDynamicThreshold || null
    async function calibrateAmbient(durationMs=300){
  if(!analyser || !audioCtx) return
      const tmp = new Float32Array(analyser.fftSize)
      const samples = []
      const start = performance.now()
      while(performance.now() - start < durationMs){
        analyser.getFloatTimeDomainData(tmp)
        let sum = 0
        for(let i=0;i<tmp.length;i++){ const v=tmp[i]; sum += v*v }
        const rms = Math.sqrt(sum/tmp.length)
        samples.push(rms)
        await new Promise(r=>setTimeout(r, 20))
      }
      // Use a robust lower-side estimate so that short spikes during
      // calibration don't push the ambient estimate too high. We take a
      // trimmed/quantile approach: compute the mean of the lower half of
      // samples (which ignores momentary loud noises), then smooth with
      // the previous ambient to avoid wild jumps.
      samples.sort((a,b)=>a-b)
      const half = Math.floor(samples.length/2) || 1
      let sumLow = 0
      for(let i=0;i<half;i++){ sumLow += samples[i] }
      const lowerMean = sumLow / half
      let ambientCandidate = lowerMean
      // smooth with previous ambient if present
      if(typeof window._prevAmbientRms === 'number' && window._prevAmbientRms > 0){
        ambientRms = window._prevAmbientRms * 0.7 + ambientCandidate * 0.3
      }else{
        ambientRms = ambientCandidate
      }
      window._prevAmbientRms = ambientRms

      // dynamic threshold = ambient * factor, with a small floor. Also
      // prevent sudden large increases by capping growth relative to the
      // previous threshold.
      const newThreshold = Math.max(ambientRms * 3.0, 0.0003)
      if(typeof window._prevDynamicThreshold === 'number' && window._prevDynamicThreshold > 0){
        // allow at most 3x increase per calibration to avoid jumping above
        // real speech levels if calibration was noisy
        dynamicThreshold = Math.min(newThreshold, window._prevDynamicThreshold * 3)
      }else{
        dynamicThreshold = newThreshold
      }
      window._prevDynamicThreshold = dynamicThreshold
      console.log('[calibrateAmbient] ambientRms=', ambientRms, 'threshold=', dynamicThreshold)
    }

    function updateMeter(rms){
      try{
        const el = document.getElementById('levelMeter')
        const dbg = document.getElementById('levelDebug')
        if(el){
          // Visualize relative to the dynamic threshold so small absolute
          // RMS values are still visible. We compute ratio = rms/threshold
          // and color the bar: green when >=1, yellow around 0.6-1, purple
          // otherwise.
          const denom = (dynamicThreshold || 0.0003)
          const ratio = rms / denom
          const pct = Math.min(1, Math.sqrt(Math.max(0, ratio)) * 0.95)
          let color = '#7c4dff'
          if(ratio >= 1) color = '#4caf50' // green
          else if(ratio >= 0.6) color = '#ffb300' // amber
          else color = '#7c4dff' // purple/primary
          el.style.background = `linear-gradient(90deg, ${color} ${(pct*100)}%, #eee ${(pct*100)}%)`
          }
        if(dbg){
          dbg.textContent = `rms:${rms.toFixed(5)} ambient:${ambientRms.toFixed(5)} thr:${dynamicThreshold.toFixed(5)}`
        }
      }catch(e){/* ignore */}
    }

    function measureSilence(){
      if(!analyser || !audioCtx) return
      _measuring = true
      const buf = new Float32Array(analyser.fftSize)
      const loop = ()=>{
        analyser.getFloatTimeDomainData(buf)
        let sum = 0
        for(let i=0;i<buf.length;i++){ const v=buf[i]; sum += v*v }
        const rms = Math.sqrt(sum / buf.length)
        lastRms = rms
        // update peak for session (helps when stop moment is quiet)
        if(rms > maxRms) maxRms = rms
        // update meter every frame
        updateMeter(rms)
        if(_measuring) requestAnimationFrame(loop)
      }
      requestAnimationFrame(loop)
    }

    async function stopRecording(e){
      e.preventDefault()
      btn.textContent = 'ğŸ“¤ é€ä¿¡ä¸­...'
      btn.classList.remove('recording')
      if(!recorder) return

      // Ensure onstop handler is set before calling stop() to avoid race condition
      recorder.onstop = async ()=>{
        try{
          _measuring = false
          if(sourceNode){ try{ sourceNode.disconnect() }catch(_){} sourceNode=null }
          if(audioCtx){ try{ audioCtx.close() }catch(_){} audioCtx=null }
          if(!chunks || chunks.length === 0){
            throw new Error('éŒ²éŸ³ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“')
          }
          const blob = new Blob(chunks, {type: recorder.mimeType || 'audio/webm'})
          // if RMS is very low compared to dynamic threshold, treat as silence and offer retry
          console.log('[stopRecording] lastRms=', lastRms, 'maxRms=', maxRms, 'dynamicThreshold=', dynamicThreshold)
          // Decide using both the end RMS and the peak RMS during recording.
          // If neither the final level nor the peak exceed the threshold
          // (allowing a small headroom for peak), treat as silence.
          const peakRequired = dynamicThreshold * 0.8
          if(lastRms < dynamicThreshold && maxRms < peakRequired){
            // show retry modal
            showRetryModal()
            return
          }
          const fd = new FormData(); fd.append('file', blob, 'voice.webm')
          // send to /api/groq/audio
          const res = await fetch('/api/groq/audio', {method:'POST', body:fd})
          if(!res.ok) throw new Error('éŸ³å£°é€ä¿¡å¤±æ•—')
          const j = await res.json()
          const transcript = (j.transcript || '').trim()

          if(!transcript){
            // ç©ºçµæœã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¸ã‚ã‹ã‚Šã‚„ã™ãä¼ãˆã‚‹
            showModal(`<strong>éŸ³å£°èªè­˜ã§ãã¾ã›ã‚“ã§ã—ãŸ</strong><br>ã‚‚ã†ä¸€åº¦ã‚†ã£ãã‚Šè©±ã—ã¦ã¿ã¦ãã ã•ã„ã€‚`)
            return
          }

          // now call /api/groq/text to get reply
          const r2 = await fetch('/api/groq/text', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({text:transcript})})
          if(!r2.ok) throw new Error('è¿”ä¿¡å–å¾—å¤±æ•—')
          const jr = await r2.json()
          showModal(`<strong>ã‚ãªãŸã®å ±å‘Š:</strong><br>${transcript}<br><br><strong>éšŠé•·ã®è¿”äº‹:</strong><br>${jr.output || 'å¿œç­”ãŒã‚ã‚Šã¾ã›ã‚“'}`)
          // Also save the transcript as a comment so teachers can see it
          try{
            await saveComment(transcript)
          }catch(err){
            console.warn('saveComment failed', err)
          }
        }catch(err){
          console.error(err)
          alert('é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + err.message)
        }finally{
          btn.textContent = 'ğŸ¤ é•·æŠ¼ã—ã§å ±å‘Š'
        }
      }

      // now stop the recorder (onstop is already set)
      try{
        recorder.stop()
      }catch(err){
        console.error('recorder.stop error', err)
        btn.textContent = 'ğŸ¤ é•·æŠ¼ã—ã§å ±å‘Š'
      }
    }

  </script>
</body>
</html>